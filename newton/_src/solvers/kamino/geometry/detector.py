# SPDX-FileCopyrightText: Copyright (c) 2025 The Newton Developers
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Provides a unified interface for performing Collision Detection in Kamino.

Usage example:

    # Create a model builder
    builder = ModelBuilderKamino()
    # ... add bodies and collision geometries to the builder ...

    # Finalize the model
    model = builder.finalize(device="cuda:0")

    # Create a collision detector with desired settings
    settings = CollisionDetectorSettings(
        pipeline="unified",
        broadphase="explicit",
        bvtype="aabb",
    )

    # Create the collision detector
    detector = CollisionDetector(model=model, settings=settings)
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import IntEnum
from typing import Literal

import warp as wp

from ..core.data import DataKamino
from ..core.model import ModelKamino
from ..core.state import StateKamino
from ..core.types import override
from ..geometry.contacts import (
    DEFAULT_GEOM_PAIR_CONTACT_GAP,
    DEFAULT_GEOM_PAIR_MAX_CONTACTS,
    DEFAULT_MODEL_MAX_CONTACTS,
    ContactsKamino,
)
from ..geometry.primitive import BoundingVolumeType, CollisionPipelinePrimitive
from ..geometry.unified import CollisionPipelineUnifiedKamino

###
# Module interface
###

__all__ = [
    "BroadPhaseType",
    "CollisionDetector",
    "CollisionDetectorSettings",
    "CollisionPipelineType",
]


###
# Module configs
###

wp.set_module_options({"enable_backward": False})


###
# Types
###


class CollisionPipelineType(IntEnum):
    """Defines the collision detection pipelines supported in Kamino."""

    PRIMITIVE = 0
    """
    Use the "fast" collision detection pipeline specialized for geometric
    primitives using an "explicit" broad-phase on pre-computed collision
    shape pairs and a narrow-phase using Newton's primitive colliders.
    """

    UNIFIED = 1
    """
    Use Newton's unified collision-detection pipeline using a configurable
    broad-phase that supports `NXN`, `SAP`, or `EXPLICIT` modes, and a
    unified GJK/MPR-based narrow-phase. This pipeline is more general and
    supports arbitrary collision geometries, including meshes and SDFs.
    """

    @classmethod
    def from_string(cls, s: str) -> CollisionPipelineType:
        """Converts a string to a CollisionPipelineType enum value."""
        try:
            return cls[s.upper()]
        except KeyError as e:
            raise ValueError(f"Invalid CollisionPipelineType: {s}. Valid options are: {[e.name for e in cls]}") from e

    @override
    def __str__(self):
        """Returns a string representation of the collision detector mode."""
        return f"CollisionDetectorMode.{self.name} ({self.value})"

    @override
    def __repr__(self):
        """Returns a string representation of the collision detector mode."""
        return self.__str__()


class BroadPhaseType(IntEnum):
    """Defines the broad-phase collision detection modes supported in Kamino."""

    NXN = 0
    """
    Use an `NXN` broad-phase that considers all possible pairs of collision shapes as candidates.

    This mode is simple but can be inefficient for models with many collision shapes.
    """

    SAP = 1
    """
    Use a Sweep and Prune (SAP) broad-phase that sorts collision shapes along a chosen axis
    and only considers overlapping shapes as candidates for narrow-phase collision detection.

    This mode is more efficient than `NXN` for models with many collision
    shapes, especially when they are sparsely distributed in space.
    """

    EXPLICIT = 2
    """
    Use an explicit broad-phase that relies on pre-computed candidate pairs
    of collision shapes, typically generated by the ModelBuilderKamino based
    on heuristics such as proximity and connectivity.

    This mode can be the most efficient when the candidate pairs are
    well-chosen, but it requires additional setup during model building.
    """

    @classmethod
    def from_string(cls, s: str) -> BroadPhaseType:
        """Converts a string to a BroadPhaseType enum value."""
        try:
            return cls[s.upper()]
        except KeyError as e:
            raise ValueError(f"Invalid BroadPhaseType: {s}. Valid options are: {[e.name for e in cls]}") from e

    @override
    def __str__(self):
        """Returns a string representation of the broad-phase type."""
        return f"BroadPhaseType.{self.name} ({self.value})"

    @override
    def __repr__(self):
        """Returns a string representation of the broad-phase type."""
        return self.__str__()


###
# Interfaces
###


@dataclass
class CollisionDetectorSettings:
    """Defines the settings for configuring a CollisionDetector."""

    pipeline: Literal["primitive", "unified"] = "primitive"
    """
    The type of collision-detection pipeline to use, either `primitive` or `unified`.\n
    Defaults to `primitive`.
    """

    broadphase: Literal["nxn", "sap", "explicit"] = "explicit"
    """
    The broad-phase collision-detection to use (`nxn`, `sap`, or `explicit`).\n
    Defaults to `explicit`.
    """

    bvtype: Literal["aabb", "bs"] = "aabb"
    """
    The type of bounding volume to use in the broad-phase.\n
    Defaults to `aabb`.
    """

    max_contacts: int = DEFAULT_MODEL_MAX_CONTACTS
    """
    The maximum number of contacts to generate over the entire model.\n
    Used to compute the total maximum contacts allocated for the model,
    in conjunction with the total number of candidate geom-pairs.\n
    Defaults to `DEFAULT_MODEL_MAX_CONTACTS` (`1000`).
    """

    max_contacts_per_world: int | None = None
    """
    The per-world maximum contacts allocation override.\n
    If specified, it will override the per-world maximum number of contacts
    computed according to the candidate geom-pairs represented in the model.\n
    Defaults to `None`, allowing contact allocations to occur according to the model.
    """

    max_contacts_per_pair: int = DEFAULT_GEOM_PAIR_MAX_CONTACTS
    """
    The maximum number of contacts to generate per candidate geom-pair.\n
    Used to compute the total maximum contacts allocated for the model,
    in conjunction with the total number of candidate geom-pairs.\n
    Defaults to `DEFAULT_GEOM_PAIR_MAX_CONTACTS` (`12`).
    """

    max_triangle_pairs: int = 1_000_000
    """
    The maximum number of triangle-primitive shape pairs to consider in the narrow-phase.\n
    Used only when the model contains triangle meshes or heightfields.\n
    Defaults to `1_000_000`.
    """

    default_gap: float = DEFAULT_GEOM_PAIR_CONTACT_GAP
    """
    The default detection gap [m] applied as a floor to per-geometry gaps.\n
    Defaults to `1e-5`.
    """

    def __post_init__(self):
        """Post-initialization processing to check if string literals correspond to supported enum types."""
        pipelines_supported = [e.name.lower() for e in CollisionPipelineType]
        if self.pipeline not in pipelines_supported:
            raise ValueError(f"Invalid CD pipeline type: {self.pipeline}. Valid options are: {pipelines_supported}")
        broadphases_supported = [e.name.lower() for e in BroadPhaseType]
        if self.broadphase not in broadphases_supported:
            raise ValueError(
                f"Invalid CD broad-phase type: {self.broadphase}. Valid options are: {broadphases_supported}"
            )
        bvtypes_supported = [e.name.lower() for e in BoundingVolumeType]
        if self.bvtype not in bvtypes_supported:
            raise ValueError(f"Invalid CD bounding-volume type: {self.bvtype}. Valid options are: {bvtypes_supported}")


class CollisionDetector:
    """
    Provides a Collision Detection (CD) front-end for Kamino.

    This class is responsible for performing collision detection as well
    as managing the collision containers and their memory allocations.

    Supports two collision pipeline types:

    - `PRIMITIVE`: A fast collision pipeline with specialized for geometric
    primitives using an "explicit" broad-phase on pre-computed collision
    shape pairs and a narrow-phase using Newton's primitive colliders.

    - `UNIFIED`: Newton's unified collision-detection pipeline using a configurable
    broad-phase that supports `NXN`, `SAP`, or `EXPLICIT` modes, and a unified
    GJK/MPR-based narrow-phase. This pipeline is more general and supports arbitrary
    collision geometries, including meshes and SDFs.
    """

    def __init__(
        self,
        model: ModelKamino | None = None,
        settings: CollisionDetectorSettings | None = None,
        device: wp.DeviceLike = None,
    ):
        """
        Initialize the CollisionDetector.

        Args:
            model (`ModelKamino`, optional):
                The model container holding the time-invariant data of the system being simulated.\n
                If provided, the detector will be finalized using the provided model and settings.\n
                If `None`, the detector will be created empty without allocating data, and
                can be finalized later by providing a model to the `finalize` method.\n
            device (`wp.DeviceLike`, optional):
                The target Warp device for allocation and execution.\n
                If `None`, the `model.device` will be used if a model is provided, otherwise
                it will default to the device preferred by Warp on the given platform.

        """
        # Cache the target device
        self._device: wp.DeviceLike = device

        # Cache a reference to the target model
        self._model: ModelKamino | None = model

        # Cache the collision detector settings
        self._settings: CollisionDetectorSettings | None = settings

        # Declare the contacts container
        self._contacts: ContactsKamino | None = None

        # Declare the collision detection pipelines
        self._pipeline_type: CollisionPipelineType | None = None
        self._unified_pipeline: CollisionPipelineUnifiedKamino | None = None
        self._primitive_pipeline: CollisionPipelinePrimitive | None = None

        # Declare and initialize the caches of contacts allocation sizes
        self._model_max_contacts: int = 0
        self._world_max_contacts: list[int] = [0]

        # Finalize the collision detector if a model is provided
        if model is not None:
            self.finalize(model=model, settings=settings, device=device)

    ###
    # Properties
    ###

    @property
    def device(self) -> wp.DeviceLike:
        """Returns the device on which the CollisionDetector data is allocated and executes."""
        return self._device

    @property
    def model(self) -> ModelKamino | None:
        """Returns the model associated with the CollisionDetector."""
        return self._model

    @property
    def settings(self) -> CollisionDetectorSettings | None:
        """Returns the settings used to configure the CollisionDetector."""
        return self._settings

    @property
    def contacts(self) -> ContactsKamino | None:
        """Returns the ContactsKamino container managed by the CollisionDetector."""
        return self._contacts

    @property
    def model_max_contacts(self) -> int:
        """Returns the total maximum number of contacts allocated for the model across all worlds."""
        return self._model_max_contacts

    @property
    def world_max_contacts(self) -> list[int]:
        """Returns the maximum number of contacts allocated for each world."""
        return self._world_max_contacts

    ###
    # Operations
    ###

    def finalize(
        self,
        model: ModelKamino | None = None,
        settings: CollisionDetectorSettings | None = None,
        device: wp.DeviceLike = None,
    ):
        """
        Allocates CollisionDetector data on the target device.

        Args:
            model (ModelKamino, optional):
                The model container holding the time-invariant data of the system being simulated.\n
                If provided, the detector will be finalized using the provided model and settings.\n
                If `None`, the detector will be created empty without allocating data, and
                can be finalized later by providing a model to the `finalize` method.\n
            settings (CollisionDetectorSettings, optional):
                Settings to configure the CollisionDetector.\n
                If `None`, uses default settings.
            device (wp.DeviceLike, optional):
                The target Warp device for allocation and execution.\n
                If `None`, the `model.device` will be used if a model is provided, otherwise
                it will default to the device preferred by Warp on the given platform.
        """
        # Override the model if specified explicitly
        if model is not None:
            self._model = model

        # Check that the model is valid
        if self._model is None:
            raise ValueError("Cannot finalize CollisionDetector: model is `None`")
        elif not isinstance(self._model, ModelKamino):
            raise TypeError(f"Cannot finalize CollisionDetector: expected ModelKamino, got {type(self._model)}")

        # Override the device if specified explicitly
        if device is not None:
            self._device = device
        # Otherwise, use the device of the model
        else:
            self._device = self._model.device

        # Override the settings if specified, ensuring that they are valid
        if settings is not None:
            if not isinstance(settings, CollisionDetectorSettings):
                raise TypeError(
                    f"Cannot finalize CollisionDetector: expected CollisionDetectorSettings, got {type(settings)}"
                )
            self._settings = settings
        # If no settings are provided, use the defaults
        if self._settings is None:
            self._settings = CollisionDetectorSettings()

        # Configure the collision detection pipeline type based on the settings
        self._pipeline_type = CollisionPipelineType.from_string(self._settings.pipeline)

        # TODO: FIX THIS SO THAT PER-WORLD MAX IS ACTUALLY BASED ON THE NUM OF COLLIDABLE
        # GOEMS IN EACH WORLD, INSTEAD OF JUST DIVIDING THE MODEL MAX BY THE NUM WORLDS
        # For collision pipeline, we don't multiply by per-pair factors since broad phase
        # discovers pairs dynamically. Users can provide rigid_contact_max explicitly,
        # otherwise it is estimated from shape count and broad phase mode.
        if self._model.geoms.model_minimum_contacts > 0:
            self._model_max_contacts = self._model.geoms.model_minimum_contacts
            self._world_max_contacts = self._model.geoms.world_minimum_contacts
        else:
            # Estimate based on broad phase mode and available information
            if self._settings.broadphase == "explicit" and self._model.geoms.collidable_pairs is not None:
                # For EXPLICIT mode, we know the maximum possible pairs
                # Estimate ~10 contacts per shape pair (conservative for mesh-mesh contacts)
                self._model_max_contacts = max(self._settings.max_contacts, self._model.geoms.num_collidable_pairs * 10)
            else:
                # For NXN/SAP dynamic broad phase, estimate based on shape count
                # Assume each shape contacts ~20 others on average (conservative estimate)
                # This scales much better than O(NÂ²) while still being safe
                self._model_max_contacts = max(self._settings.max_contacts, self._model.geoms.num_collidable * 20)

            # Set the world max contacts to be the same for all worlds in the model
            num_worlds = self._model.size.num_worlds
            self._world_max_contacts = [self._model_max_contacts // num_worlds] * num_worlds

        # Create the contacts interface which will allocate all contacts data arrays
        # NOTE: If internal allocations happen, then they will contain
        # the contacts generated by the collision detection pipelines
        self._contacts = ContactsKamino(capacity=self._world_max_contacts, device=self._device)

        # Proceed with allocations only if the model admits contacts, which
        # occurs when collision geometries defined in the builder and model
        if self._model_max_contacts > 0:
            # Initialize the configured collision detection pipeline
            match self._pipeline_type:
                case CollisionPipelineType.PRIMITIVE:
                    self._primitive_pipeline = CollisionPipelinePrimitive(
                        device=self._device,
                        model=self._model,
                        bvtype=self._settings.bvtype,
                        default_gap=self._settings.default_gap,
                    )
                case CollisionPipelineType.UNIFIED:
                    self._unified_pipeline = CollisionPipelineUnifiedKamino(
                        device=self._device,
                        model=self._model,
                        broadphase=self._settings.broadphase,
                        default_gap=self._settings.default_gap,
                        max_triangle_pairs=self._settings.max_triangle_pairs,
                        max_contacts_per_pair=self._settings.max_contacts_per_pair,
                    )
                case _:
                    raise ValueError(f"Unsupported CollisionPipelineType: {self._pipeline_type}")

    def collide(self, data: DataKamino, state: StateKamino, contacts: ContactsKamino | None = None):
        """
        Executes collision detection given a model and its associated data.

        This operation will use the `primitive` or `unified` pipeline depending on
        the configuration set during the initialization of the CollisionDetector.

        Args:
            data (DataKamino):
                The solver data container holding solver-specific internal geome/shape data.
            state (StateKamino):
                The state container holding the time-varying state of simulation.
            contacts (ContactsKamino, optional):
                An optional ContactsKamino container to store the generated contacts.
                If `None`, uses the internal ContactsKamino container managed by the CollisionDetector.
        """
        # If no contacts can be generated, skip collision detection
        if contacts is not None:
            _contacts = contacts
        else:
            _contacts = self._contacts

        # Skip this operation if no contacts data has been allocated
        if _contacts is None or _contacts.model_max_contacts_host <= 0:
            return

        # Ensure that a collision detection pipeline has been created
        if self._primitive_pipeline is None and self._unified_pipeline is None:
            raise RuntimeError("Cannot perform collision detection: a collision pipeline has not been created")

        # Ensure that the data is valid
        if data is None:
            raise ValueError("Cannot perform collision detection: data is None")
        if not isinstance(data, DataKamino):
            raise TypeError(f"Cannot perform collision detection: expected DataKamino, got {type(data)}")

        # Ensure that the state is valid
        if state is None:
            raise ValueError("Cannot perform collision detection: state is None")
        if not isinstance(state, StateKamino):
            raise TypeError(f"Cannot perform collision detection: expected StateKamino, got {type(state)}")

        # Execute the configured collision detection pipeline
        match self._pipeline_type:
            case CollisionPipelineType.PRIMITIVE:
                self._primitive_pipeline.collide(data, state, _contacts)
            case CollisionPipelineType.UNIFIED:
                self._unified_pipeline.collide(data, state, _contacts)
            case _:
                raise ValueError(f"Unsupported CollisionPipelineType: {self._pipeline_type}")
